#!/usr/bin/env GemVM

import Window;
import Math;

var sin = Math.sin;
var cos = Math.cos;

class Vec3 {
    init(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    add(other) {
        return Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
    }

    sub(other) {
        return Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
    }

    rotateX(angle) {
        var cosA = cos(angle);
        var sinA = sin(angle);
        var y = this.y * cosA - this.z * sinA;
        var z = this.y * sinA + this.z * cosA;
        return Vec3(this.x, y, z);
    }

    rotateY(angle) {
        var cosA = cos(angle);
        var sinA = sin(angle);
        var x = this.x * cosA - this.z * sinA;
        var z = this.x * sinA + this.z * cosA;
        return Vec3(x, this.y, z);
    }

    rotateXY(rx, ry) {
        var cx = cos(rx);
        var sx = sin(rx);
        var cy = cos(ry);
        var sy = sin(ry);
        var x = this.x;
        var y = this.y;
        var z = this.z;

        var x2 = cy * x - sy * z;
        var y2 = sy * sx * x + cx * y + cy * sx * z;
        var z2 = sy * cx * x - sx * y + cy * cx * z;
        return Vec3(x2, y2, z2);
    }

    dot(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z;
    }

    cross(other) {
        return Vec3(
            this.y * other.z - this.z * other.y,
            this.z * other.x - this.x * other.z,
            this.x * other.y - this.y * other.x
        );
    }
}

func project(v3, screenW, screenH, fov, viewerDist) {
    var factor = fov / (viewerDist + v3.z);
    var x = v3.x * factor + screenW / 2;
    var y = -v3.y * factor + screenH / 2;
    return [x, y];
}

var lastMouseX = 0;
var lastMouseY = 0;
var rotateX = 0.0;
var rotateY = 0.0;
var sensitivity = 0.005;
var isClicked = false;

var cubeOrigin = Vec3(0, 0, 0);

func update() {
    var pos = Window.getMousePos();
    try {
        var dx = pos[0] - lastMouseX;
        var dy = pos[1] - lastMouseY;

        lastMouseX = pos[0];
        lastMouseY = pos[1];

        rotateY = rotateY + dx * sensitivity;
        rotateX = rotateX - dy * sensitivity;
    } catch (e) {
        println(pos);
    }
}

var cubeVerts = [
    Vec3(-1, -1, -1), Vec3(1, -1, -1),
    Vec3(1, 1, -1), Vec3(-1, 1, -1),
    Vec3(-1, -1, 1), Vec3(1, -1, 1),
    Vec3(1, 1, 1), Vec3(-1, 1, 1)
];

var faces = [
    [3, 2, 1, 0],  // back
    [4, 5, 6, 7],  // front
    [0, 1, 5, 4],  // bottom
    [3, 7, 6, 2],  // top
    [0, 4, 7, 3],  // left
    [1, 2, 6, 5]   // right
];

Window.init(800, 600, "Rotating Cube - Mouse Controlled");

func visibleFaces(verts, faces) {
    var visible = [];

    for (var i = 0; i < faces.length(); i = i + 1) {
        var face = faces[i];

        var v0 = verts[face[0]];
        var v1 = verts[face[1]];
        var v2 = verts[face[2]];

        var edge1 = v1.sub(v0);
        var edge2 = v2.sub(v0);

        var normal = edge1.cross(edge2);
        var toCam = Vec3(0,0,0).sub(v0);

        if (normal.dot(toCam) > 0) {
            visible.append(i);
        }
    }

    return visible; // list of indices into `faces`
}

func sortFaces(faceData) {
    var n = faceData.length();
    for (var i = 0; i < n - 1; i = i + 1) {
        for (var j = 0; j < n - i - 1; j = j + 1) {
            if (faceData[j][0] < faceData[j + 1][0]) {
                var temp = faceData[j];
                faceData[j] = faceData[j + 1];
                faceData[j + 1] = temp;
            }
        }
    }
}

while (true) {
    Window.clear(0);
    if (isClicked) update();

    var event = Window.pollEvent();
    if (event != nil) {
        if (event[0] == "quit") break;
        if (event[0] == "mouse_down" and event[1] == "mouse_left") {
            isClicked = true;
            var pos = Window.getMousePos();
            lastMouseX = pos[0];
            lastMouseY = pos[1];
        } else if (event[0] == "mouse_up" and event[1] == "mouse_left") {
            isClicked = false;
        }
    }

    var rotatedVerts = [];
    for (var i = 0; i < cubeVerts.length(); i = i + 1) {
        var v = cubeVerts[i];
        var rotated = v.rotateX(rotateX).rotateY(rotateY);
        rotatedVerts.append(rotated);
    }

    var faceData = [];
    for (var i = 0; i < faces.length(); i = i + 1) {
        var f = faces[i];
        var avgZ = (
            rotatedVerts[f[0]].z +
            rotatedVerts[f[1]].z +
            rotatedVerts[f[2]].z +
            rotatedVerts[f[3]].z
        ) / 4;

        faceData.append([avgZ, f]);
    }

    sortFaces(faceData);

    for (var i = 0; i < faceData.length(); i = i + 1) {
        var f = faceData[i][1];

        var p0 = project(rotatedVerts[f[0]], 800, 600, 256, 3);
        var p1 = project(rotatedVerts[f[1]], 800, 600, 256, 3);
        var p2 = project(rotatedVerts[f[2]], 800, 600, 256, 3);
        var p3 = project(rotatedVerts[f[3]], 800, 600, 256, 3);

        var baseColor = 33023;
        var redBoost = (faceData[i][0] * 50 \ 1) * 65536;
        var depthColor = baseColor + redBoost;

        Window.drawTrig(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1], depthColor);
        Window.drawTrig(p0[0], p0[1], p2[0], p2[1], p3[0], p3[1], depthColor);
        Window.drawLine(p0[0], p0[1], p1[0], p1[1], 0);
        Window.drawLine(p1[0], p1[1], p2[0], p2[1], 0);
        Window.drawLine(p2[0], p2[1], p3[0], p3[1], 0);
        Window.drawLine(p3[0], p3[1], p0[0], p0[1], 0);
    }

    Window.update();
}

Window.exit();
